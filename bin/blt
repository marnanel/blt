#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use XML::Tiny qw(parsefile);
use IO::Scalar;
use App::BLT;
use vars qw($VERSION);

$VERSION = '0.20';
my $home = $ENV{HOME} || (getpwuid($<))[7];
our $rc_filename = "$home/.bltrc.xml";
our $pid_filename = "$home/.blt_pid";

our ($check, $set,
  $sync, $force, $help, $version, $username,
  $check_public);

Getopt::Long::Configure ("bundling");
GetOptions(
  'check|c'   => \$check,
  'set|s'     => \$set,
  'help|h'    => \$help,
  'version|v' => \$version,
  'force|F'   => \$force,
  'sync|S'    => \$sync,
  'public|P'  => \$check_public,
  'as|a=s'    => \$username,
 );

if ($version) {
  print 'blt version $VERSION\n';
  exit(2);
}

if ($help) {
  print_masthead();
  print_help();
  exit(1);
}

our $last_fetch_filename = "$home/.blt_last_fetch";
our $timeline = $check_public? 'public': 'friends';

our (%rc_settings, $last_fetch);

if (-e $rc_filename) {

  # We already have the information
  
  my $document = parsefile($rc_filename)->[0];
  $rc_settings{interval} = $document->{'attrib'}->{'interval'};
  die "Interval not defined in $rc_filename\n"
    unless defined $rc_settings{interval};

  if ($username) {
    for (@{$document->{'content'}}) {
      if ($_->{'attrib'}->{'id'} eq $username) {
        $rc_settings{'user'} = $username;
        $rc_settings{'pass'} = $_->{'attrib'}->{'pass'};
        last;
      }
    }
  } else {
    # take the first one
    my $first = $document->{'content'}->[0]->{'attrib'};
    if (defined $first) {
      $rc_settings{'user'} = $first->{'id'};
      $rc_settings{'pass'} = $first->{'pass'};
    }
  }

  die "User was not found in $rc_filename\n"
    unless defined $rc_settings{'user'} && defined $rc_settings{'pass'};

} elsif ($check && $check_public) {
  # We're doing a public timeline check but without a config file.
  # We can do this, but we need to supply some results.
  $rc_settings{'interval'} = 60;

} else {
  # Okay, just create it.

  print_masthead();
  print "Hi! It looks like you haven't used blt before. To get started,\n";
  print "I'll just need two pieces of information about your twitter\n";
  print "account. If you don't have a twitter account yet, you can get\n";
  print "one at <http://twitter.com/signup>.\n\n";

  print "What is your username on twitter? ";
  my $user = <STDIN>;
  chomp $user;

  print "And what is your password on twitter? ";
  my $pass = <STDIN>;
  chomp $pass;

  # write all that out to an XML file
  # FIXME: Need to check that they don't use crazy entity-needing
  # chars before release
  
  print "Writing out to $rc_filename... ";
  open RC, ">$rc_filename" or die "Can't open file $rc_filename: $!\n";
  print RC "<?xml version=\"1.0\"?>\n<bltrc interval=\"60\">";
  print RC "<ac id=\"$user\" pass=\"$pass\"/></bltrc>\n";
  close RC or die "Can't close file $rc_filename: $!\n";

  %rc_settings = (
    %rc_settings,
    'user' => $user,
    'pass' => $pass,
  );

  # Also attempt to put ourselves into PROMPT_COMMAND in ~/.bashrc
  add_to_bashrc();
}

# TODO: Use file date of empty file rather than reading file
if (-e $last_fetch_filename) {
  open LASTFETCH, "<$last_fetch_filename" or die "Can't open $last_fetch_filename: $!";
  $last_fetch = <LASTFETCH>;
  close LASTFETCH or die "Can't close $last_fetch_filename: $!";

  die "The file $last_fetch_filename has become corrupted; please delete it ".
    "and run $0 again" unless defined $last_fetch;
} else {
  $last_fetch = 0;
}

# ...and we're off!

our $content_filename = "$home/.blt_content";

if ($check) {

  # Too soon to check?

  if (!$force &&
    $last_fetch+$rc_settings{interval} > time) {

    # It's too soon to check. But if the background process
    # isn't running, we should check whether there's content
    # to supply.

    if (-e $content_filename && !already_running_in_background()) {

      open CONTENT, "<$content_filename" or die "Can't open $content_filename: $!";
      my $content = <CONTENT>;
      close CONTENT or die "Can't close $content_filename: $!";

      if ($content) {
        print $content;

        # And now we've printed it, delete the content.
        unlink $content_filename;
      }
    }

    # Anyway, whatever, it's too soon to check, so we should leave.
    exit(0);
  }

  # If we get here, we need to check and it's a good time to do so.

  if ($sync) {
    # Synchronous check; just go and find the
    # data and print it. That's easy.
    print twitter_following($last_fetch);
    exit(0);
  }

  # Otherwise, if we have a copy running in the
  # background, we can bail because someone's
  # dealing with the problem.

  exit(0) if already_running_in_background();

  # Okay, so the problem needs dealing with and
  # nobody's doing anything about it. So I suppose
  # it's down to us.

  exit(0) if fork(); # Go background

  open PIDFILE, ">$pid_filename" or die "$0: can't open $pid_filename: $!";
  print PIDFILE $$;
  close PIDFILE or die "$0: can't close $pid_filename: $!";

  my $content = twitter_following($last_fetch);
  open CONTENT, ">>$content_filename" or die "Can't open $content_filename: $!";
  print CONTENT $content;
  close CONTENT or die "Can't close $content_filename: $!";

  unlink $pid_filename or die "$0: Can't delete $pid_filename: $!";

} elsif (@ARGV) {

  # so it must be --set, the default.
  die "You can't post to the public timeline!" if $check_public;

  my $status = join(' ', @ARGV);
  
  twitter_post($status);

} else {
  print_masthead();
  print_help();
}

=head1 NAME

blt - bash loves twitter - command-line client for twitter

=head1 SYNOPSIS

    blt eating ice-cream and loving python
    blt "It's all in a day's work when you protect apostrophes"
    blt --check --public --sync

=head1 DESCRIpTION

lt is a command-line client for twitter.com, designed to integrate
helpfully with F<bash>.  It makes sending messages simple, and
receiving them as simple as with the old F<biff> program which
tld you when you had new mail.

=head1 WHAT IS TWITTER?

Twitter is a blogging system which limits posts (known as "tweets")
to 140 characters.  This means that users can receive them easily
over text messaging, instant messaging, and so on.

Twitter allows you to send three kinds of messages:

=over 4

=item
The ordinary public kind, directed at everyone, to tell them
what you're currently doing or thinking.

=item
Directed messages, which are pointed at one particular user
but still public.  These contain "@username".  A user can opt
to not be told about directed messages not aimed at people
they know.

=item
 Private messages.  These are only seen by the sender and the
recipient.  blt can send these using the "d" notation (see
PRIVTE MESSAGES below) but does not yet show them when you
ask it to check.

=back 4

=head1 SWITCHES

foo

=head1 THE PUBLIC TIMELINE

The public timmeline is a list of all public posts made to twitter
in the last few seconds.  Unlike all other modes, the public
timeline does not require any authentication on your part.

You can read the public timeline with no configuration file.
This will mean that the minimum time between fetching each new
set of information from Twitter is 60 seconds.

=head1 THE CONFIGURATION FILE

The configuration file is a simple piece f XML called ~/.bltrc.xml.
Its root node is F<bltrc>, which has one attribute, F<interval>.
This is the minimum time that must pass between fetching information
from Twitter.  (The Twitter acceptale use policy requires this to
be at least 52 seconds.)

Within this root element are a number of F<ac> elements, each
representing an account, with F<id> and F<pass> elements.
On initial creation, only one account
exists.  You may add new accounts in the same format and
select it using the F<-a> switch; see above under SWITCHES.

=head1 BUGS

=over 4
=item
It can send but not receive direct messages.

=item
blt is pretty fast, but you still might not want to run blt
from ~/.bashrc on a particularly slow computer.

=back 4

