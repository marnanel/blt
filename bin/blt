#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use XML::Tiny qw(parsefile);
use IO::Scalar;
use vars qw($VERSION);

$VERSION = '0.20';
my $home = $ENV{HOME} || (getpwuid($<))[7];
our $rc_filename = "$home/.bltrc.xml";
our $last_fetch_filename = "$home/.blt_last_fetch";
our $pid_filename = "$home/.blt_pid";

my ($check, $set,
  $sync, $force, $help, $version, $username);

GetOptions(
  'check|c'   => \$check,
  'set|s'     => \$set,
  'help|h'    => \$help,
  'version|v' => \$version,
  'force|F'   => \$force,
  'sync|S'    => \$sync,
  'as|a=s'    => \$username,
 );

if ($version) {
  print 'blt version $VERSION\n';
  exit(2);
}

if ($help) {
  print_masthead();
  print_help();
  exit(1);
}

our (%rc_settings, $last_fetch);

if (-e $rc_filename) {

  # We already have the information
  
  my $document = parsefile($rc_filename)->[0];
  $rc_settings{interval} = $document->{'attrib'}->{'interval'};
  die "Interval not defined in $rc_filename\n"
    unless defined $rc_settings{interval};

  if ($username) {
    for (@{$document->{'content'}}) {
      if ($_->{'attrib'}->{'id'} eq $username) {
        $rc_settings{'user'} = $username;
        $rc_settings{'pass'} = $_->{'attrib'}->{'pass'};
        last;
      }
    }
  } else {
    # take the first one
    my $first = $document->{'content'}->[0]->{'attrib'};
    if (defined $first) {
      $rc_settings{'user'} = $first->{'id'};
      $rc_settings{'pass'} = $first->{'pass'};
    }
  }

  die "User was not found in $rc_filename\n"
    unless defined $rc_settings{'user'} && defined $rc_settings{'pass'};

} else {

  print_masthead();
  print "Hi! It looks like you haven't used blt before. To get started,\n";
  print "I'll just need two pieces of information about your twitter\n";
  print "account. If you don't have a twitter account yet, you can get\n";
  print "one at <http://twitter.com/signup>.\n\n";

  print "What is your username on twitter? ";
  my $user = <STDIN>;
  chomp $user;

  print "And what is your password on twitter? ";
  my $pass = <STDIN>;
  chomp $pass;

  # write all that out to an XML file
  # FIXME: Need to check that they don't use crazy entity-needing
  # chars before release
  
  print "Writing out to $rc_filename... ";
  open RC, ">$rc_filename" or die "Can't open file $rc_filename: $!\n";
  print RC "<?xml version=\"1.0\"?>\n<bltrc interval=\"60\">";
  print RC "<ac id=\"$user\" pass=\"$pass\"/></bltrc>\n";
  close RC or die "Can't close file $rc_filename: $!\n";

  # Also attempt to put ourselves into PROMPT_COMMAND in ~/.bashrc
  add_to_bashrc();
}

if (-e $last_fetch_filename) {
  open LASTFETCH, "<$last_fetch_filename" or die "Can't open $last_fetch_filename: $!";
  $last_fetch = <LASTFETCH>;
  close LASTFETCH or die "Can't close $last_fetch_filename: $!";

  die "The file $last_fetch_filename has become corrupted; please delete it ".
    "and run $0 again" unless defined $last_fetch;
} else {
  $last_fetch = 0;
}

# ...and we're off!

our $content_filename = "$home/.blt_content";

if ($check) {

  # Too soon to check?

  if (!$force &&
    $last_fetch+$rc_settings{interval} > time) {

    # It's too soon to check. But if the background process
    # isn't running, we should check whether there's content
    # to supply.

    if (-e $content_filename && !already_running_in_background()) {

      open CONTENT, "<$content_filename" or die "Can't open $content_filename: $!";
      my $content = <CONTENT>;
      close CONTENT or die "Can't close $content_filename: $!";

      if ($content) {
        print $content;

        # And now we've printed it, delete the content.
        unlink $content_filename;
      }

    }

    # Anyway, whatever, it's too soon to check, so we should leave.
    exit(0);
  }

  # If we get here, we need to check and it's a good time to do so.

  if ($sync) {
    # Synchronous check; just go and find the
    # data and print it. That's easy.
    print twitter_following($last_fetch);
    exit(0);
  }

  # Otherwise, if we have a copy running in the
  # background, we can bail because someone's
  # dealing with the problem.

  exit(0) if already_running_in_background();

  # Okay, so the problem needs dealing with and
  # nobody's doing anything about it. So I suppose
  # it's down to us.

  exit(0) if fork(); # Go background

  open PIDFILE, ">$pid_filename" or die "$0: can't open $pid_filename: $!";
  print PIDFILE $$;
  close PIDFILE or die "$0: can't close $pid_filename: $!";

  my $content = twitter_following($last_fetch);
  open CONTENT, ">>$content_filename" or die "Can't open $content_filename: $!";
  print CONTENT $content;
  close CONTENT or die "Can't close $content_filename: $!";

  unlink $pid_filename or die "$0: Can't delete $pid_filename: $!";

} elsif (@ARGV) {

  # so it must be --set, the default.

  my $status = join(' ', @ARGV);
  
  twitter_post($status);

} else {
  print_help();
}


sub print_masthead {
  print <<EOT;
blt - bash loves twitter - shell/twitter integration
Copyright (c) 2008 Thomas Thurman - tthurman\@gnome.org - http://marnanel.org
blt is released in the hope that it will be useful, but with NO WARRANTY.
blt is released under the terms of the GNU General Public Licence.

EOT
}

sub print_help {
  print <<EOT;
Choose at most one mode:
  -c, --check = print updates from Twitter
  -s, --set = update Twitter from command line (default)
  -h, --help = show this text
  -v, --version = show version number
  -a, --as=USER = post as USER, if you add them in ~/.bltrc.xml

Switches:
  -F, --force = always check, even if we checked recently
  -S, --sync  = don't check in the background
EOT
}

sub add_to_bashrc {
  my $bashrc = "$home/.bashrc";

  if (-e $bashrc) { # if they don't have one, don't bother checking

    local $/;
    undef $/;

    open BASHRC, "<$bashrc" or die "Can't open $bashrc: $!";
    my $bashrc = <BASHRC>;
    close BASHRC or die "Can't close $bashrc: $!";

    return if ($bashrc =~ /^[^#\n]*PROMPT_COMMAND/m);
  }

  print "\nAttempting to add ourselves to $bashrc...";

  open BASHRC, ">>$bashrc" or die "Can't open $bashrc: $!";
  print BASHRC "\n\n# Added by $0\nexport PROMPT_COMMAND=\"$0 --check\"\n"
        or die "Can't write to $bashrc: $!";
  close BASHRC or die "Can't close $bashrc: $!";

  print "done.\n\n";
  print "You will need to log out and back in to get\n";
  print "automatic notifications.\n";
}

sub already_running_in_background {
  if (-e $pid_filename) {

    my @stats = stat($pid_filename);
    my $age = time-($stats[9]);

    if ($age > 60) {
      # oh, that's just silly. Nobody takes a whole minute
      unlink $pid_filename;
      return 0;
    }

    # Maybe we should also check that the PID is valid,
    # but I think that's overkill.

    return 1;
  } else {
    return 0;
  }
}

#############################
# Here's our roll-your-own Twitter library
# because Net::Twitter is a bit clunky.
# It is very simple, and still in a lot of flux.
#
# This will eventually become Net::Twitter::Simple,
# or something like that.
#############################

sub twitter_useragent {

  # If we get here, we need LWP. But don't "use" it because that's an
  # implicit BEGIN{} (so we will always incur the hit of loading it,
  # even though the general case is that we don't need it).
  eval { require LWP::UserAgent; };

  # Create a user agent object
  my $ua = LWP::UserAgent->new(timeout => 5);

  $ua->credentials('twitter.com:80', 'Twitter API',
    $rc_settings{user},
    $rc_settings{pass},
  );

  $ua->default_header('X-Twitter-Client' => 'blt');
  $ua->default_header('X-Twitter-Client-Version' => 'prealpha');
  $ua->default_header('X-Twitter-Client-URL' => 'http://marnanel.org/projects/blt/');

  return $ua;
}

sub twitter_post {
  my ($status) = @_;

  my $ua = twitter_useragent();
  my $response = $ua->post(
    'http://twitter.com/statuses/update.xml',
    {
      status => $status,
      source => 'blt',
    }
  );

  die $response->status_line unless $response->is_success;

}

sub twitter_following {

  my ($since) = @_;

  my $ua = twitter_useragent();

  if (defined $since) {
    eval {
      require POSIX; import POSIX qw(setlocale LC_ALL strftime);
      setlocale(LC_ALL(), 'C');
      # note that the "since" parameter is not currently working with Twitter
      $ua->default_header('If-Modified-Since', strftime("%a, %d %b %Y %T GMT", gmtime($since)));
    }
  }

  my $response = $ua->get(
    'http://twitter.com/statuses/friends_timeline.xml',
  );

  open LAST_FETCH, ">$last_fetch_filename" or die "Can't open $last_fetch_filename: $!";
  print LAST_FETCH time;
  close LAST_FETCH or die "Can't close $last_fetch_filename: $!";

  if ($response->code == 500 && $response->status_line =~ /Can't connect/) {
    return "blt: failed to reach twitter; won't check again for a while\n".$response->status_line."\n";
  }

  return '' if $response->code == 304; # Not Modified
  die $response->status_line unless $response->is_success;

  use Data::Dumper;

  my (@results, $screenname, $text);

  for (@{parsefile(new IO::Scalar \($response->content))->[0]->{'content'}}) {

    for my $field (@{ $_->{'content'} }) {
      if ($field->{'name'} eq 'text') {
        $text = $field->{'content'}->[0]->{'content'};
      } elsif ($field->{'name'} eq 'user') {
        for my $user_field (@{ $field->{'content'}}) {
          if ($user_field->{'name'} eq 'screen_name') {
            $screenname = $user_field->{'content'}->[0]->{'content'};
            last; # that's all we need to know about a user
          }
        }
      }
    }

    push @results, [$screenname, $text];
  }

  my $result = '';

  foreach (@results) {

    my ($screenname, $text) = @{$_};
    $result .= "<$screenname> $text\n";
  }

  return $result;
}
