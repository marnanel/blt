#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use XML::Tiny qw(parsefile);
use IO::Scalar;
use App::BLT;
use vars qw($VERSION);

$VERSION = '0.20';
my $home = $ENV{HOME} || (getpwuid($<))[7];
our $rc_filename = "$home/.bltrc.xml";
our $last_fetch_filename = "$home/.blt_last_fetch";
our $pid_filename = "$home/.blt_pid";

my ($check, $set,
  $sync, $force, $help, $version, $username);

GetOptions(
  'check|c'   => \$check,
  'set|s'     => \$set,
  'help|h'    => \$help,
  'version|v' => \$version,
  'force|F'   => \$force,
  'sync|S'    => \$sync,
  'as|a=s'    => \$username,
 );

if ($version) {
  print 'blt version $VERSION\n';
  exit(2);
}

if ($help) {
  print_masthead();
  print_help();
  exit(1);
}

our (%rc_settings, $last_fetch);

if (-e $rc_filename) {

  # We already have the information
  
  my $document = parsefile($rc_filename)->[0];
  $rc_settings{interval} = $document->{'attrib'}->{'interval'};
  die "Interval not defined in $rc_filename\n"
    unless defined $rc_settings{interval};

  if ($username) {
    for (@{$document->{'content'}}) {
      if ($_->{'attrib'}->{'id'} eq $username) {
        $rc_settings{'user'} = $username;
        $rc_settings{'pass'} = $_->{'attrib'}->{'pass'};
        last;
      }
    }
  } else {
    # take the first one
    my $first = $document->{'content'}->[0]->{'attrib'};
    if (defined $first) {
      $rc_settings{'user'} = $first->{'id'};
      $rc_settings{'pass'} = $first->{'pass'};
    }
  }

  die "User was not found in $rc_filename\n"
    unless defined $rc_settings{'user'} && defined $rc_settings{'pass'};

} else {

  print_masthead();
  print "Hi! It looks like you haven't used blt before. To get started,\n";
  print "I'll just need two pieces of information about your twitter\n";
  print "account. If you don't have a twitter account yet, you can get\n";
  print "one at <http://twitter.com/signup>.\n\n";

  print "What is your username on twitter? ";
  my $user = <STDIN>;
  chomp $user;

  print "And what is your password on twitter? ";
  my $pass = <STDIN>;
  chomp $pass;

  # write all that out to an XML file
  # FIXME: Need to check that they don't use crazy entity-needing
  # chars before release
  
  print "Writing out to $rc_filename... ";
  open RC, ">$rc_filename" or die "Can't open file $rc_filename: $!\n";
  print RC "<?xml version=\"1.0\"?>\n<bltrc interval=\"60\">";
  print RC "<ac id=\"$user\" pass=\"$pass\"/></bltrc>\n";
  close RC or die "Can't close file $rc_filename: $!\n";

  # Also attempt to put ourselves into PROMPT_COMMAND in ~/.bashrc
  add_to_bashrc();
}

if (-e $last_fetch_filename) {
  open LASTFETCH, "<$last_fetch_filename" or die "Can't open $last_fetch_filename: $!";
  $last_fetch = <LASTFETCH>;
  close LASTFETCH or die "Can't close $last_fetch_filename: $!";

  die "The file $last_fetch_filename has become corrupted; please delete it ".
    "and run $0 again" unless defined $last_fetch;
} else {
  $last_fetch = 0;
}

# ...and we're off!

our $content_filename = "$home/.blt_content";

if ($check) {

  # Too soon to check?

  if (!$force &&
    $last_fetch+$rc_settings{interval} > time) {

    # It's too soon to check. But if the background process
    # isn't running, we should check whether there's content
    # to supply.

    if (-e $content_filename && !already_running_in_background()) {

      open CONTENT, "<$content_filename" or die "Can't open $content_filename: $!";
      my $content = <CONTENT>;
      close CONTENT or die "Can't close $content_filename: $!";

      if ($content) {
        print $content;

        # And now we've printed it, delete the content.
        unlink $content_filename;
      }

    }

    # Anyway, whatever, it's too soon to check, so we should leave.
    exit(0);
  }

  # If we get here, we need to check and it's a good time to do so.

  if ($sync) {
    # Synchronous check; just go and find the
    # data and print it. That's easy.
    print twitter_following($last_fetch);
    exit(0);
  }

  # Otherwise, if we have a copy running in the
  # background, we can bail because someone's
  # dealing with the problem.

  exit(0) if already_running_in_background();

  # Okay, so the problem needs dealing with and
  # nobody's doing anything about it. So I suppose
  # it's down to us.

  exit(0) if fork(); # Go background

  open PIDFILE, ">$pid_filename" or die "$0: can't open $pid_filename: $!";
  print PIDFILE $$;
  close PIDFILE or die "$0: can't close $pid_filename: $!";

  my $content = twitter_following($last_fetch);
  open CONTENT, ">>$content_filename" or die "Can't open $content_filename: $!";
  print CONTENT $content;
  close CONTENT or die "Can't close $content_filename: $!";

  unlink $pid_filename or die "$0: Can't delete $pid_filename: $!";

} elsif (@ARGV) {

  # so it must be --set, the default.

  my $status = join(' ', @ARGV);
  
  twitter_post($status);

} else {
  print_masthead();
  print_help();
}

